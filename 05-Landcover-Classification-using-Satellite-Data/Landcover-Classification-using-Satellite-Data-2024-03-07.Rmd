---
title: "Landcover Classification using Satellite Data"
author: "S&DS 361"
date: "2024-02-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(pubtheme)
```

## Introduction

Satellite data can be used to estimate the type of landcover (built-up, cropland, natural forest, orchard) at locations around the world. This approach can be an time and cost effective alternative to manually inspecting these locations in person. 

## Data

The data `labeled_points.Rdata` contains data on blocks of land in Benin.

```{r}
load('data/labeled_points.Rdata')
```

The file contains two data frames. 

**1. labeled.** The object `labeled` has 400 locations (with unique identifier `ID`). The `landcover` type at each location has been manually labeled by a human. Each `ID` has a unique latitude (`lat`) and longitude (`lon`) and can be thought of as a pixel in an image. 

```{r}
head(labeled,2) %>%
  as.data.frame()
```

The four labels are 

- **natforest.** natural vegetation
- **cropland.** annual, ground-based crops.
- **orchard.** tree crops
- **builtup.** buildings or roads. 


**2. labeled_train.** The object `labeled_train` has 3 years of satellite imagery for each `ID`. Images were collected every 16 days, and the `year`, `month`, `day`, and `date` for each location are given in the data. These were all taken by the [Landsat 7](https://www.usgs.gov/landsat-missions/landsat-7) satellite. The other columns are 

- **ID.** Unique identifier for the location, same as in `labeled`.
- **B1 thru B8.** These are 8 bands from the image, including a red band, green band, blue band, infrared band, etc.  These measure the strength of the red, green, and blue wavelengths in an image as well as the strength of other wavelengths on the electromagnetic spectrum that are not visible to the human eye. You can find more information about these on the [Landsat 7](https://www.usgs.gov/landsat-missions/landsat-7) page.
- **NDVI.** [Normalized Difference Vegetation Index](https://gisgeography.com/ndvi-normalized-difference-vegetation-index/). The Normalized Difference Vegetation Index (NDVI) is a common index used for summarizing satellite image data. According to its [Wikipedia](https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index#:~:text=The%20normalized%20difference%20vegetation%20index,observed%20contains%20live%20green%20vegetation) page, NDVI "is a simple graphical indicator that can be used to analyze remote sensing measurements, often from a space platform, assessing whether or not the target being observed contains live green vegetation."  Note that the formula given on that page is $$ NDVI = \frac{NIR - Red}{NIR + Red} $$ The data you've been given contains both the NIR (near-infrared) and Red bands (bands 4 and 3, respectively, according to https://www.usgs.gov/landsat-missions/landsat-7). 
- **NDBI.** Normal Difference Built-up Index. Like NDVI, but for detecting built-up areas.
- **EVI.** Enhanced Vegetation Index. Like NDVI, but performs better under [some conditions](https://www.usgs.gov/landsat-missions/landsat-enhanced-vegetation-index).

```{r}
labeled_train %>%
  as.data.frame() %>%
  head(2)
```

These band values will be different depending on the landcover type. Some known relationships

- NDVI is known to be a very good indicator of vegetation
- The band values show seasonal trends, since landcover can show seasonal changes (e.g. trees lose their leaves in the fall)
- The peaks and troughs can be shifted in time for different landcover types (different types of vegetation peak at different times).
- The difference between peaks and troughs can vary among landcover types. 

We can join these data sets on `ID`. 

```{r}
labeled = labeled %>% 
  select(ID, landcover)

d = labeled_train %>%
  left_join(labeled, by = 'ID')
```

Finally, let's add a column for vegetation called `veg` that is 1 if the `landcover` is `natforest`, `orchard`, or `cropland`, and 0 otherwise. 

```{r}
d = d %>%
  mutate(veg = ifelse(landcover %in% c('natforest', 'orchard', 'cropland'), 
                      1, 0), 
         builtup = ifelse(landcover == 'builtup', 1, 0), 
         EVI = ifelse(is.infinite(EVI), NA, EVI))
```

## Vegetation and band values

It will likely be helpful to perform data exploration and visualization to determine which bands vary the most among landcover types, which bands are relatively similar across landcover types, and to detect other potential trends in the data. Let's start by focusing on `veg` and exploring the relationship between `veg` and the band values. 

### Mean band values and vegetation 

```{r}
## The heads of the original data sets, in case you are curious
## But it is not necessary to look at this.
# labeled_train %>%
#   as.data.frame() %>%
#   head(2)
# labeled %>% head(2)

## Create a data set that is one row per location
## with mean(NDVI), mean(B7), and landcover type for each location
dm = d %>%
  group_by(ID) %>%
  summarise(
    B1   = mean(B1, na.rm=T),
    B2   = mean(B2, na.rm=T),
    B3   = mean(B3, na.rm=T),
    B4   = mean(B4, na.rm=T),
    B5   = mean(B5, na.rm=T),
    B6_VCID_1 = mean(B6_VCID_1, na.rm=T),
    B6_VCID_2 = mean(B6_VCID_2, na.rm=T),
    B7   = mean(B7, na.rm=T),
    NDVI = mean(NDVI, na.rm=T), 
    NDBI = mean(NDBI, na.rm=T),
    EVI  = mean(EVI, na.rm=T),
    landcover = unique(landcover)) %>%
  ungroup() %>%
  mutate(veg = ifelse(landcover %in% c('natforest', 'orchard', 'cropland'), 
                      1, 0), 
         builtup = ifelse(landcover == 'builtup', 1, 0), 
         EVI = ifelse(is.infinite(EVI), NA, EVI)) %>%
  as.data.frame()
head(d)
```


We see now that there are 400 rows

```{r}
nrow(dm)
```

and that each row has `ID`, `landcover` type, and band values. 


Here is a summary of the mean band values for each landcover type. 

```{r}
dg = dm %>% 
  select(-landcover, -builtup) %>%
  pivot_longer(cols = -c(ID, veg)) %>%
  group_by(name, veg) %>%
  summarise(mean = mean(value, 
                        na.rm = T)) %>%
  mutate(mean = round(mean, 2), 
         veg = paste0('veg', veg)) %>%
  pivot_wider(names_from = veg, 
              values_from = mean) %>%
  mutate(diff = veg1 - veg0)
dg  

```

Histogram of all bands, separated by `veg`. 

```{r}
dg = dm %>% 
  select(-landcover, -builtup) %>%
  pivot_longer(cols = -c(ID, veg)) %>%
  mutate(veg = factor(veg))
head(dg)

g = ggplot(dg, 
           aes(x = value, 
               fill = veg)) +
  geom_density(alpha = 0.3) +
  facet_wrap(~name, 
             scales = 'free')

g %>% 
  pub(type = 'hist', 
      facet = T, 
      base_size = 9)
  
```

Scatter plot of bands vs veg

```{r}
dg = dg %>%
  mutate(veg = as.numeric(as.character(veg)))

g = ggplot(dg, 
           aes(x = value, 
               y = veg)) +
  geom_jitter(alpha  = 0.7, 
              height = 0.2,
              width  = 0) +
  geom_smooth() + 
  facet_wrap(~name, 
             scales = 'free')

g %>% 
  pub(type = 'scatter', 
      facet = T, 
      base_size = 9, 
      ybreaks = c(0, 0.5, 1))
```

Here is a scatter plot of `NDVI` vs `veg`. 

```{r fig.height=4, fig.width=4}
g = ggplot(dm, 
       aes(NDVI, 
           veg))+
  geom_jitter(height = 0.1, 
              width  = 0) + 
  geom_smooth() 

g %>% pub()
```



Corrplot of all bands

```{r}
library(corrplot)
dcor = dm %>% 
  select(-ID, -veg, -builtup, -landcover) %>%
  mutate(EVI = ifelse(is.infinite(EVI), NA, EVI)) %>%
  cor(use = 'pairwise.complete.obs')
dcor %>% round(2)
corrplot(dcor)

```

Pairs plot with points colored by label. We'll omit some bands that are highly correlated with others to make the plot more readable. 

```{r fig.height = 8, fig.width = 8}
library(GGally)
title = 'Band values and landcover type'
dg = dm %>%
  mutate(veg = factor(veg))
bands = c('B1', #'B2', 'B3', 
  'B4', 'B5', 
  'B6_VCID_1', #'B6_VCID_2', 
  'B7', 'NDVI', 'NDBI', 'EVI')

g = ggpairs(dg, 
            aes(color = veg, 
                fill  = veg, 
                alpha = 0.1, 
                shape = '20'),
            columns = bands,
            diag    = list(continuous = pub.density)) +
  labs(title    = title) +
  theme_pub(type = 'pairs', 
            base_size = 8)
g
```

Let's zoom in on a couple of these. Here is NVDI and B7

```{r}

```

B5 and B7

```{r}

```



### Seasonality

Bands over time for `veg = 1` and `veg = 0`. 

```{r warning = F, message = F}
dd = d %>% 
  filter(!is.infinite(EVI)) %>%
  select(-lat, -lon, -landcover, -builtup) %>%
  pivot_longer(cols = c(-ID, -veg, -year, 
                        -month, -day, -date)) %>%
  mutate(year.mon = year+month/12) %>%
  group_by(veg, 
           year.mon, 
           name) %>%
  summarise(value = mean(value)) %>% 
  mutate(veg = factor(veg)) 
head(dd)

title = "Intensity of bands over time" 
g = ggplot(dd, 
           aes(x = year.mon, 
               y = value, 
               color = veg))+
  geom_line(linewidth = .75)+
  geom_point(size = 1)+
  facet_wrap(~name, 
             scales = 'free_y') + 
  labs(title = title,
       x = 'Date', 
       y = 'Intensity')

 g %>% 
   pub(type = 'line', 
       facet = T, 
       base_size = 10,
       xbreaks = c(2018, 2019, 2020), 
       xlabels = as.character(c(2018, 2019, 2020))) 
```

A smoothed version of the same figure. 

```{r warning = FALSE, message = F}
title = "Intensity of bands over time" 
g = ggplot(dd, 
           aes(x = year.mon, 
               y = value, 
               color = veg))+
  geom_smooth(linewidth = .75, 
              se = F, 
              span = 0.3)+
  geom_point(size = 1)+
  facet_wrap(~name, 
             scales = 'free_y') + 
  labs(title = title,
       x = 'Date', 
       y = 'Intensity')

 g %>% 
   pub(type = 'line', 
       facet = T, 
       base_size = 10,
       xbreaks = c(2018, 2019, 2020), 
       xlabels = as.character(c(2018, 2019, 2020))) 
```

Same plot but using the non-aggregate data points.

```{r eval = F, warning = F, message = F}
dg = d %>% 
  filter(!is.infinite(EVI)) %>%
  select(-lat, -lon, -landcover, -builtup) %>%
  pivot_longer(cols = c(-ID, -veg, -year, 
                        -month, -day, -date)) %>%
  mutate(veg = factor(veg)) %>% 
  filter(name %in% bands)
#head(dg)

title = "Intensity of bands over time" 
g = ggplot(dg, 
           aes(x = date, 
               y = value, 
               color = veg))+
  geom_smooth(linewidth = 1, 
              se = F)+
  geom_jitter(size = .5, 
              alpha = 0.1, 
              height = 0, 
              width = 7)+
  facet_wrap(~name, 
             scales = 'free_y') + 
  labs(title = title,
       x = 'Date', 
       y = 'Intensity')

g %>% 
  pub(type = 'line', 
      facet = T, 
      base_size = 10) 
 
gg = g %>%
  pub(type = 'line',
      facet = T,
      base_size = 32)

ggsave(filename=paste0("img/", gsub("%", " Perc", title), ".jpg"),
       plot   = gg,
       width  = 20,
       height = 16,
       units  = 'in',
       dpi    = 72)
```

![](img/Intensity of bands over time.jpg)

## veg and mean NDVI

Let's look at the proportion of `veg` for different subsets of `NDVI`. 

We can bin our data using the function `cut_interval`.

```{r}
dm = dm %>%
  mutate(bin = cut_interval(NDVI, 
                            length = 0.05))
head(dd)
```

Let's check the counts of `veg` in each bin. 

```{r}

bin.means = dm %>% 
  group_by(bin, veg) %>%
  count() %>%
  pivot_wider(names_from = veg, 
              values_from = n, 
              values_fill = 0) %>%
  mutate(n = `0` + `1`, 
         p = `1`/n)
bin.means
```


Let's plot the distribution of score separately for every bin. 

```{r}
g = ggplot(dm, 
           aes(x = veg))+
  geom_histogram()+
  facet_wrap(~bin, 
             scales = 'free_y', 
             dir = 'v')

g %>% 
  pub(type = 'hist', 
      facet = T, 
      base_size = 9)
```

Let's plot these observation proportions on our scatter plot

```{r}
bin.means = bin.means %>%
  ungroup() %>% #################### !!!!!!!!!!!!
  mutate(mid = seq(-.125, .225, by = 0.05))

g = ggplot(dm,
           aes(x = NDVI, 
               y = veg)) +
  geom_jitter(alpha = 0.5, 
              height = 0.2, 
              width = 0) + 
  geom_point(data = bin.means, 
             aes(x = mid, 
                 y = p, 
                 size = n), 
             color = pubred) + 
  geom_line(data = bin.means, 
            aes(x = mid, 
                y = p), 
            color = pubred)

g %>%
  pub(type = 'scatter', 
      ybreaks = c(0, 0.5, 1))
```

Fit a logistic regression model for `veg` with one predictor (mean `NDVI`).


```{r}

```



## Create other predictors

Let's create some predictors for each location (aka do some "feature engineering") based on observations made during the data exploration above.


## Logistic Regression with multiple predictors



## Vegetation classification



## Landcover types and band values



## Landcover classification


